---
description: >-
  Está sessão apresenta um passo a passo de pentest (teste de
  penetração/intrusão) baseado em informações coletadas do Guia de teste de
  segurança móvel da OWASP (OWASP Mobile Security Testing Guide).
---

# Passo a Passo

* Instalar **Virtual Box Oracle** \([https://www.virtualbox.org/](https://www.virtualbox.org/)\).
* Baixar a ISO do Sistema Operacional **Santoku** \(\([https://santoku-linux.com/download/](https://santoku-linux.com/download/)\).
* Instalação de alguns drivers que ajudarão o SO a se comportar bem \(drivers presentes na sessão de Ferramentas\).

![](.gitbook/assets/0.png)

![](.gitbook/assets/1.png)

* Reiniciar, agora é possível utilizar o Full screen mode.
* Criar uma conta no site do **Genymotion**
* Instalar **Genymotion**\(emulador Android\)
* Criando uma imagem android

![](.gitbook/assets/2.png)

* Configurar o modo de rede na configuração\(dentro do Genymotion\) para Bridge
* Conectar o **ADB**\(Android Debug Bridge\) entre o SO e o Emulador

![](.gitbook/assets/3.png)

* **$ adb shell \(entrando nos files do android\)**
* **$ cd /data/app \(apps do android\)**
* Explorando mais o Emulador

![](.gitbook/assets/4.png)

* Ter qualquer apk e instalar dentro do genymotion: **$ adb install “apk.file.apk”**
*  **$ adb logcat** \(ter acesso aos log das aplicações\)

![](.gitbook/assets/5.png)

![](.gitbook/assets/6.png)

* Do emulador para a ISO\(imagem\):

![](.gitbook/assets/7.png)

## 1. Android App

* **Classes.dex\(file\)**, analisar como o app funciona
* **AndroidManifest.xml \(file\)**, características do app, e também com **META-INF\(folder\)** podendo descobrir qual tipo de permissão do usuário, um código fonte completo, enquanto gerenciador de intenção de atividades.
* **res\(folder\), assests\(folder\) e lib\(folder\),** como componentes adicionais.

![](.gitbook/assets/8.png)

![](.gitbook/assets/9.png)

* **$ vim classes.dex**

![](.gitbook/assets/10.png)

* Não verá nada porque há a necessidade de descompilar.
* **Android-apktool,** ferramenta APK para reverter ou descompilar qualquer arquivo APK do android. \(já instalado no Santoku \(SO\)
* **JaDX Decompiler,** reverter o aplicativo Android.

![](.gitbook/assets/11.png)

* **$ apktool d app.apk, “d” de decompiler.**
* Descompilando:

![](.gitbook/assets/12.png)

* Primeiro App sem permissões de usuario em “androidmanifest.xml”
* **$ vim AndroidManifest.xml**, para ver as permissões de usuário

![](.gitbook/assets/13.png)

* **“smali”** é o diretório que contém nosso código-fonte, diretório que varia de acordo com o desenvolvimento da aplicação.

![](.gitbook/assets/14.png)

* **$ cd smali**, conseguindo ter acesso ao código.

![](.gitbook/assets/15.png)

![](.gitbook/assets/16.png)

* Outra maneira é pelo **Jadx**

![](.gitbook/assets/17.png)

* Link : [https://github.com/skylot/jadx/releases/download/v1.2.0/jadx-1.2.0.zip](https://github.com/skylot/jadx/releases/download/v1.2.0/jadx-1.2.0.zip)

## **2.** **Android Application Signing**

* Assinar um app antes de torná-lo publico, através de um certificado de autoridade ou uma auto-assinatura, através de diferentes algoritmos de criptografia, tendo as duas chaves a pública e privada, mantendo a segunda em segurança.
  * **Assinatura JAR \(esquema v1\)**

    É baseado em JAR assinado . As assinaturas v1 não protegem algumas partes do APK, como metadados ZIP. O verificador de APK precisa processar muitas estruturas de dados não confiáveis ​​\(ainda não verificadas\) e, em seguida, descartar os dados não cobertos pelas assinaturas. Isso oferece uma superfície de ataque considerável. Além disso, o verificador de APK deve descompactar todas as entradas compactadas, consumindo mais tempo e memória. 

  * **Esquema de assinatura APK v2 e v3 \(esquema v2 +\)**

    O esquema v2 foi atualizado para v3 no Android 9 para incluir informações adicionais no bloco de assinatura, mas de outra forma funciona da mesma forma. O conteúdo do APK é hash e assinado, então o APK Signing Block resultante é inserido no APK. 

    Durante a validação, o esquema v2 + trata o arquivo APK como um blob e executa a verificação de assinatura em todo o arquivo. Qualquer modificação no APK, incluindo modificações nos metadados ZIP, invalida a assinatura do APK. Essa forma de verificação de APK é substancialmente mais rápida e permite a detecção de mais classes de modificações não autorizadas.

## **3. Tráfego Android**

* **Passivo:** analisando o tráfego secretamente, capturando os dados para a análise posterior, farejando o pacote TCP.
* **Ativo:** interceptação de solicitação de usuário, por exemplo, utilizando algumas ferramentos proxy, como **BURPSUITE.**

![](.gitbook/assets/18.png)

* Ferramenta já presente no Santoku SO.
* Primeiro: **Proxy &lt; Options &lt; Edit\(Selecionando o primeiro\) &lt; All interfaces**

![](.gitbook/assets/19.png)

* Obs: Configure a Placa em modo Bridge no virtual Box : **Botão direito &lt; Configuraçoes &lt; Rede &lt; Placa em modo Bridge**

![](.gitbook/assets/20.png)

* **$ Ifconfig** , para pegar o ip do SO

![](.gitbook/assets/21.png)

## 4 . Configurações de Proxy com o IP do Santoku \(SO\)

![](.gitbook/assets/22.png)

![](.gitbook/assets/23.png)

* Digitando qualquer coisa no navegador

![](.gitbook/assets/24.png)

* Interceptação

![](.gitbook/assets/25.png)

* Instalar o certificado do **burp** no android: http://burp

![](.gitbook/assets/26.png)

![](.gitbook/assets/27.png)

![](.gitbook/assets/28.png)

![](.gitbook/assets/29.png)

![](.gitbook/assets/30.png)

* **Configurações &lt; Segurança &lt; Instalar do cartao SD &lt; certificado.crt**

## **5.** Aplicativo de Teste \(**DIVA - Damn Insecure and Vulnerable Application\)**

* Link : payatu.com/damn-insecure-and-vulnerable-app/
* Procure por “diva-beta.apk”

![](.gitbook/assets/31.png)

* Instalar o **010 Editor** para analisar arquivos.dex transformandos em arquivos java futuramente.
* Link : [www.sweetscape.com/download/010editor/](http://www.sweetscape.com/download/010editor/)
* Analisando os Logs de app
* Descobrindo que o processo é “21425” podemos através do comando $adb logcat \| grep 21425

![](.gitbook/assets/32.png)

* Conseguimos armazenar o número do cartao de crédito através dos **Logs.**

## 6. Problemas de Codificação \(HardcodeActivity\)

* Descobringo o codigo **“HardcodeActivity”** descobrimos uma key

![](.gitbook/assets/33.jpeg)

![](.gitbook/assets/34.png)

* Com essa key, seria possível garantir algum acesso no app.

## **7.** **Armazenamento de Dados de Forma Insegura**

* Em um app que armazena login e senha temos:

![](.gitbook/assets/35.png)

* Salvando um password : **admin, secretpassword**

![](.gitbook/assets/36.png)

* Assim como em hardcore inssues, analisamos através do **“jd-gui”** as classes.dex que foram transformadas em codigos .jar através do comando **$ d2j-dex2jar classes.dex**

![](.gitbook/assets/37.png)

* Através do comando **$ jd-gui “classes .dex** transformadas em **“.jar”** para alise do código fonte, sendo possivelmente as atividades inseguras do logon

![](.gitbook/assets/38.jpeg)

* Ao abrir código podem ver um metodo que salva as credencias de user e password, em seguida voltamos ao Santoku e ao emulador atraves do **$ adb shell**

![](.gitbook/assets/39.jpeg)

* Entramos em seguida **$ data/data**,
* **$ cd jakhar.assem.diva**
* **$ cd $shared\_prefs**
* e vemos que existem um arquivo chamado **“jakhar.assem.diva\_preferences.xml”**
* usando **$ cat jakhar.assem.diva\_preferences.xml**, podemos ter acesso ao nosso login e senha salvos.

![](.gitbook/assets/40.jpeg)

## **8. Banco de Dados Inseguro**

* Salvando um login como demo, e password como secretpassword em outra partição, vamos tentar descobrir aonde estão esses dados.

![](.gitbook/assets/41.png)

* Usando a mesma técnica anterior, analisamos novamente a codificação e vemos sua estrutura e como está armazenado e vamos ver se está ou não criptografado

![](.gitbook/assets/42.jpeg)

* No android usamos o comando **$ sqlite3 ids**, pelo fato desse banco é o mais comum nos androids. Depois um **.tables**, e faremos um **select** para visualizar

![](.gitbook/assets/43.jpeg)

## **9. Arquivos Temporários Inseguros**

* Usando demo como login e demodemodemo como senha

![](.gitbook/assets/44.png)

* Abrimos novamente o **jd-gui,** e as classes.2jat para analisar o código temporários

![](.gitbook/assets/45.jpeg)

* Seguindo o mesmo processo dos tópicos anteriores conseguimos visualizar os arquivos temporários

![](.gitbook/assets/46.png)

* Utilizando novamente o **$ cat uinfo-1634723552tmp**

![](.gitbook/assets/47.png)

* obtendo assim, os dados do arquivo temporário.

## **10. Dados do Cartão SD**

* Utilizando dessa vez “lucas” como login e “senhamuitosecreta” como password

![](.gitbook/assets/48.png)

* Analisaremos novamente o código fonte atraves do **“jd-gui”**, conseguimos observar como o método funciona e como e salvo o arquivos

![](.gitbook/assets/49.jpeg)

* Procurando agora no **SDCARD** pelo arquivo, utilizaremos o comando $ ls -a, para encontrar os arquivos ocultos

![](.gitbook/assets/50.png)

* **Encontramos** o **“uinfo.txt”** abrindo novamente com o comando **“cat”** e tendo assim acesso as credenciais ocultas

![](.gitbook/assets/51.png)

## **11. SQL INJECTION**

* Colocando algo malicioso na entrada de dados onde o app não valida ou higieniza os dados de inserção, podendo resultar no despejo de todo o banco de dados.
* Em uma caixa de busca, supostamente colocamos algo malicioso e assim que é pressionado o botao de “search” tentaremos recuperar todos os dados.
* Verificando o código fonte novamente para analisar a estrutura e olhando o select

![](.gitbook/assets/52.jpeg)

* Obtemos: **“SELECT \* FROM sqliuser WHERE user = “+ localEditText.getText\(\).toString+””**
* Inserindo algo malicioso no código como uma condição para mostrar os dados com o código **“SELECT \* FROM sqliuser WHERE user = ‘ 1’ or ‘ 1’=’1 ”**, podemos simplesmente depois na própria barra de pesquisa digitá-lo para ter acesso a database:

![](.gitbook/assets/53.png)

## **12. Vasculhando o WEBVIEW**

**O que é?**

* Pequeno navegador no nosso app para mostrar o conteúdo da WEB

![](.gitbook/assets/54.png)

![](.gitbook/assets/55.png)

* Verificar algum acesso interino relacionado, no caso acima existe o **demo.txt** e assim conseguimos dados

![](.gitbook/assets/56.jpeg)

![](.gitbook/assets/57.jpeg)

## **13. Lendo o AndroidManifest.xml e Obtendo Credenciais**

![](.gitbook/assets/58.jpeg)

![](.gitbook/assets/59.jpeg)

![](.gitbook/assets/60.jpeg)

![](.gitbook/assets/61.jpeg)

## **14.** Provedor de Conteúdos \(**Content Provider\)**

* Criando um PIN com 1234

![](.gitbook/assets/62.png)

* Depois acessando o mesmo com o próprio PIN

![](.gitbook/assets/63.png)

![](.gitbook/assets/64.png)

* Encontrar os dados sem usar o PIN:
* 1 – Encontrar o Provedor URI e encontrar os dados particular os dados do mesmo
* Analisando novamente o AndroidManifest.xml

![](.gitbook/assets/65.jpeg)

![](.gitbook/assets/66.png)

* Analisaremos esse arquivo através do **$ vim AcessControl3Activity.java**
* Vimos que há um NotesProvider e também, o analisaremos

![](.gitbook/assets/67.jpeg)

* Vimos que temos um uri content : //jakhar.aseem.diva.provider.notesprovider/notes
* Usaremos o comando

![](.gitbook/assets/68.png)

* Obetendo o acesso de TODOS OS DADOS

## **15. Drozer “Engenharia Reversa”**

**Link :** labs.mrinfosecurity.com/tools/drozer

![](.gitbook/assets/69.png)

Instalar o Drozer e o drozer apk

![](.gitbook/assets/70.png)

![](.gitbook/assets/71.png)

**$ adb forward tcp:31415 tcp: 31415**

**$ drozer console connect**

**$ ls**

**$ run “modulo”**

**$ run app.package.list \(listar todos os app\)**

tendo acessos a vários modulos que podem usados para testar apps androids

![](.gitbook/assets/72.png)



